(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.

(** Should be moved to Hacspec_Lib.v **)
     Definition int_xI {WS : WORDSIZE} (a : int) : int := MachineIntegers.add (MachineIntegers.mul a (repr 2)) MachineIntegers.one.
Definition int_xO {WS : WORDSIZE} (a : int) : int := MachineIntegers.mul a (repr 2).
Number Notation int Pos.of_num_int Pos.to_num_int (via positive mapping [[int_xI] => xI, [int_xO] => xO , [MachineIntegers.one] => xH]) : hacspec_scope.
Notation "0" := (repr O).
Notation U8_t := int8.
Notation U8 := id.
Notation U16_t := int16.
Notation U16 := id.
Notation U32_t := int32.
Notation U32 := id.
Notation U64_t := int64.
Notation U64 := id.
Notation U128_t := int128.
Notation U128 := id.

Definition array_index {A: Type} `{Default A} {len : nat} (s: nseq A len) {WS} (i : @int WS) := array_index s (unsigned i).
Notation " x .[ a ]" := (array_index x a) (at level 40).
Definition array_upd {A: Type} {len : nat} (s: nseq A len) {WS} (i: @int WS) (new_v: A) : nseq A len := array_upd s (unsigned i) new_v.
Notation " x .[ i ]<- a" := (array_upd x i a) (at level 40).

Class Addition A := add : A -> A -> A.
Notation "a .+ b" := (add a b).
Instance array_add_inst {ws : WORDSIZE} {len: nat} : Addition (nseq (@int ws) len) := { add a b := a array_add b }.
Instance int_add_inst {ws : WORDSIZE} : Addition (@int ws) := { add a b := MachineIntegers.add a b }.

Class Subtraction A := sub : A -> A -> A.
Notation "a .- b" := (sub a b).
Instance array_sub_inst {ws : WORDSIZE} {len: nat} : Subtraction (nseq (@int ws) len) := { sub := array_join_map MachineIntegers.sub }.
Instance int_sub_inst {ws : WORDSIZE} : Subtraction (@int ws) := { sub a b := MachineIntegers.sub a b }.

Class Multiplication A := mul : A -> A -> A.
Notation "a .* b" := (mul a b).
Instance array_mul_inst {ws : WORDSIZE} {len: nat} : Multiplication (nseq (@int ws) len) := { mul a b := a array_mul b }.
Instance int_mul_inst {ws : WORDSIZE} : Multiplication (@int ws) := { mul a b := MachineIntegers.mul a b }.

Class Xor A := xor : A -> A -> A.
Notation "a .^ b" := (xor a b).

Instance array_xor_inst {ws : WORDSIZE} {len: nat} : Xor (nseq (@int ws) len) := { xor a b := a array_xor b }.
Instance int_xor_inst {ws : WORDSIZE} : Xor (@int ws) := { xor a b := MachineIntegers.xor a b }.

Definition new {A : Type} `{Default A} {len} : nseq A len := array_new_ default _.
Class array_or_seq A len :=
{ as_seq : seq A ; as_nseq : nseq A len }.

Arguments as_seq {_} {_} array_or_seq.
Arguments as_nseq {_} {_} array_or_seq.
Coercion as_seq : array_or_seq >-> seq.
Coercion as_nseq : array_or_seq >-> nseq.

Instance nseq_array_or_seq {A len} (a : nseq A len) : array_or_seq A len :=
{ as_seq := array_to_seq a ; as_nseq := a ; }.
Coercion nseq_array_or_seq : nseq >-> array_or_seq.

Instance seq_array_or_seq {A} `{Default A} (a : seq A) : array_or_seq A (length a) :=
{ as_seq := a ; as_nseq := array_from_seq _ a ; }.
Coercion seq_array_or_seq : seq >-> array_or_seq.

Definition update {A : Type}  `{Default A} {len slen} (s : nseq A len) {WS} (start : @int WS) (start_a : array_or_seq A slen) : nseq A len :=
array_update (a := A) (len := len) s (unsigned start) (as_seq start_a).

Definition to_le_U32s {A l} := array_to_le_uint32s (A := A) (l := l).
Axiom to_le_bytes : forall {ws : WORDSIZE} {len}, nseq (@int ws) len -> seq int8.
Definition from_seq {A : Type}  `{Default A} {len slen} (s : array_or_seq A slen) : nseq A len := array_from_seq _ (as_seq s).

Notation Seq_t := seq.
Notation len := (fun s => seq_len s : int32).

Definition array_slice {a: Type} `{Default a} {len : nat} (input: nseq a len) {WS} (start: @int WS) (slice_len: @int WS) : seq a := slice (array_to_seq input) (unsigned start) (unsigned (start .+ slice_len)).
Notation slice := array_slice.
Definition seq_new {A: Type} `{Default A} {WS} (len: @int WS) : seq A := seq_new (unsigned len).
Notation new_seq := seq_new.
Notation num_exact_chunks := seq_num_exact_chunks.
Notation get_exact_chunk := seq_get_exact_chunk.
Definition set_chunk {a: Type} `{Default a} {len} (s: seq a) {WS} (chunk_len: @int WS) (chunk_num: @int WS) (chunk: array_or_seq a len) : seq a := seq_set_chunk s (unsigned chunk_len) (unsigned chunk_num) (as_seq chunk).
Definition set_exact_chunk {a} `{H : Default a} {len} s {WS} := @set_chunk a H len s WS.
     Notation get_remainder_chunk := seq_get_remainder_chunk.
Notation "a <> b" := (negb (eqb a b)).

Notation from_secret_literal := nat_mod_from_secret_literal.
Definition pow2 {m} (x : @int WORDSIZE32) := nat_mod_pow2 m (unsigned x).
Instance nat_mod_addition {n} : Addition (nat_mod n) := { add a b := a +% b }.
Instance nat_mod_subtraction {n} : Subtraction (nat_mod n) := { sub a b := a -% b }.
Instance nat_mod_multiplication {n} : Multiplication (nat_mod n) := { mul a b := a *% b }.
Definition from_slice {a: Type} `{Default a} {len slen} (x : array_or_seq a slen) {WS} (start: @int WS) (slice_len: @int WS) := array_from_slice default len (as_seq x) (unsigned start) (unsigned slice_len).
Notation zero := nat_mod_zero.
Notation to_byte_seq_le := nat_mod_to_byte_seq_le.
Notation U128_to_le_bytes := u128_to_le_bytes.
Notation from_byte_seq_le := nat_mod_from_byte_seq_le.
Definition from_literal {m} := nat_mod_from_literal m.
Notation inv := nat_mod_inv.
Notation update_start := array_update_start.
Notation pow := nat_mod_pow_self.
Notation bit := nat_mod_bit.

Definition int_to_int {ws1 ws2} (i : @int ws1) : @int ws2 := repr (unsigned i).
Coercion int_to_int : int >-> int.
Notation push := seq_push.
Notation Build_secret := secret.
Notation "a -× b" :=
(prod a b) (at level 80, right associativity) : hacspec_scope.
Notation Result_t := (fun '(x,y) => result).
Axiom TODO_name : Type.
Notation ONE := nat_mod_one.
Notation exp := nat_mod_exp.
Notation nat_mod := GZnZ.znz.
Instance nat_mod_znz_addition {n} : Addition (GZnZ.znz n) := { add a b := a +% b }.
Instance nat_mod_znz_subtraction {n} : Subtraction (GZnZ.znz n) := { sub a b := a -% b }.
Instance nat_mod_znz_multiplication {n} : Multiplication (GZnZ.znz n) := { mul a b := a *% b }.
Notation TWO := nat_mod_two.
Notation ne := (fun x y => negb (eqb x y)).
Notation eq := (eqb).
Notation rotate_right := (ror).
Notation to_be_U32s := array_to_be_uint32s.
Notation get_chunk := seq_get_chunk.
Notation num_chunks := seq_num_chunks.
Notation U64_to_be_bytes := uint64_to_be_bytes.
Notation to_be_bytes := array_to_be_bytes.
Notation U8_from_usize := uint8_from_usize.
Notation concat := seq_concat.
Notation declassify := id.
Notation U128_from_be_bytes := uint128_from_be_bytes.
Notation U128_to_be_bytes := uint128_to_be_bytes.
Notation slice_range := array_slice_range.
Notation truncate := seq_truncate.
Axiom array_to_be_uint64s : forall {A l}, nseq A l -> seq uint64.
Notation to_be_U64s := array_to_be_uint64s.
Notation classify := id.
Notation U64_from_U8 := uint64_from_uint8.
(** end of: Should be moved to Hacspec_Lib.v **)


(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Notation SBox_t := (nseq int8 256).
Definition SBox : SBox_t -> SBox_t :=
  id.

Notation RCon_t := (nseq int8 15).
Definition RCon : RCon_t -> RCon_t :=
  id.

Notation PBytes256_t := (nseq int8 256).
Definition PBytes256 : PBytes256_t -> PBytes256_t :=
  id.

Definition SBOX : SBox_t :=
  SBox (array_from_list _ [(@repr WORDSIZE8 99);(@repr WORDSIZE8 124);(@repr WORDSIZE8 119);(@repr WORDSIZE8 123);(@repr WORDSIZE8 242);(@repr WORDSIZE8 107);(@repr WORDSIZE8 111);(@repr WORDSIZE8 197);(@repr WORDSIZE8 48);(@repr WORDSIZE8 1);(@repr WORDSIZE8 103);(@repr WORDSIZE8 43);(@repr WORDSIZE8 254);(@repr WORDSIZE8 215);(@repr WORDSIZE8 171);(@repr WORDSIZE8 118);(@repr WORDSIZE8 202);(@repr WORDSIZE8 130);(@repr WORDSIZE8 201);(@repr WORDSIZE8 125);(@repr WORDSIZE8 250);(@repr WORDSIZE8 89);(@repr WORDSIZE8 71);(@repr WORDSIZE8 240);(@repr WORDSIZE8 173);(@repr WORDSIZE8 212);(@repr WORDSIZE8 162);(@repr WORDSIZE8 175);(@repr WORDSIZE8 156);(@repr WORDSIZE8 164);(@repr WORDSIZE8 114);(@repr WORDSIZE8 192);(@repr WORDSIZE8 183);(@repr WORDSIZE8 253);(@repr WORDSIZE8 147);(@repr WORDSIZE8 38);(@repr WORDSIZE8 54);(@repr WORDSIZE8 63);(@repr WORDSIZE8 247);(@repr WORDSIZE8 204);(@repr WORDSIZE8 52);(@repr WORDSIZE8 165);(@repr WORDSIZE8 229);(@repr WORDSIZE8 241);(@repr WORDSIZE8 113);(@repr WORDSIZE8 216);(@repr WORDSIZE8 49);(@repr WORDSIZE8 21);(@repr WORDSIZE8 4);(@repr WORDSIZE8 199);(@repr WORDSIZE8 35);(@repr WORDSIZE8 195);(@repr WORDSIZE8 24);(@repr WORDSIZE8 150);(@repr WORDSIZE8 5);(@repr WORDSIZE8 154);(@repr WORDSIZE8 7);(@repr WORDSIZE8 18);(@repr WORDSIZE8 128);(@repr WORDSIZE8 226);(@repr WORDSIZE8 235);(@repr WORDSIZE8 39);(@repr WORDSIZE8 178);(@repr WORDSIZE8 117);(@repr WORDSIZE8 9);(@repr WORDSIZE8 131);(@repr WORDSIZE8 44);(@repr WORDSIZE8 26);(@repr WORDSIZE8 27);(@repr WORDSIZE8 110);(@repr WORDSIZE8 90);(@repr WORDSIZE8 160);(@repr WORDSIZE8 82);(@repr WORDSIZE8 59);(@repr WORDSIZE8 214);(@repr WORDSIZE8 179);(@repr WORDSIZE8 41);(@repr WORDSIZE8 227);(@repr WORDSIZE8 47);(@repr WORDSIZE8 132);(@repr WORDSIZE8 83);(@repr WORDSIZE8 209);(@repr WORDSIZE8 0);(@repr WORDSIZE8 237);(@repr WORDSIZE8 32);(@repr WORDSIZE8 252);(@repr WORDSIZE8 177);(@repr WORDSIZE8 91);(@repr WORDSIZE8 106);(@repr WORDSIZE8 203);(@repr WORDSIZE8 190);(@repr WORDSIZE8 57);(@repr WORDSIZE8 74);(@repr WORDSIZE8 76);(@repr WORDSIZE8 88);(@repr WORDSIZE8 207);(@repr WORDSIZE8 208);(@repr WORDSIZE8 239);(@repr WORDSIZE8 170);(@repr WORDSIZE8 251);(@repr WORDSIZE8 67);(@repr WORDSIZE8 77);(@repr WORDSIZE8 51);(@repr WORDSIZE8 133);(@repr WORDSIZE8 69);(@repr WORDSIZE8 249);(@repr WORDSIZE8 2);(@repr WORDSIZE8 127);(@repr WORDSIZE8 80);(@repr WORDSIZE8 60);(@repr WORDSIZE8 159);(@repr WORDSIZE8 168);(@repr WORDSIZE8 81);(@repr WORDSIZE8 163);(@repr WORDSIZE8 64);(@repr WORDSIZE8 143);(@repr WORDSIZE8 146);(@repr WORDSIZE8 157);(@repr WORDSIZE8 56);(@repr WORDSIZE8 245);(@repr WORDSIZE8 188);(@repr WORDSIZE8 182);(@repr WORDSIZE8 218);(@repr WORDSIZE8 33);(@repr WORDSIZE8 16);(@repr WORDSIZE8 255);(@repr WORDSIZE8 243);(@repr WORDSIZE8 210);(@repr WORDSIZE8 205);(@repr WORDSIZE8 12);(@repr WORDSIZE8 19);(@repr WORDSIZE8 236);(@repr WORDSIZE8 95);(@repr WORDSIZE8 151);(@repr WORDSIZE8 68);(@repr WORDSIZE8 23);(@repr WORDSIZE8 196);(@repr WORDSIZE8 167);(@repr WORDSIZE8 126);(@repr WORDSIZE8 61);(@repr WORDSIZE8 100);(@repr WORDSIZE8 93);(@repr WORDSIZE8 25);(@repr WORDSIZE8 115);(@repr WORDSIZE8 96);(@repr WORDSIZE8 129);(@repr WORDSIZE8 79);(@repr WORDSIZE8 220);(@repr WORDSIZE8 34);(@repr WORDSIZE8 42);(@repr WORDSIZE8 144);(@repr WORDSIZE8 136);(@repr WORDSIZE8 70);(@repr WORDSIZE8 238);(@repr WORDSIZE8 184);(@repr WORDSIZE8 20);(@repr WORDSIZE8 222);(@repr WORDSIZE8 94);(@repr WORDSIZE8 11);(@repr WORDSIZE8 219);(@repr WORDSIZE8 224);(@repr WORDSIZE8 50);(@repr WORDSIZE8 58);(@repr WORDSIZE8 10);(@repr WORDSIZE8 73);(@repr WORDSIZE8 6);(@repr WORDSIZE8 36);(@repr WORDSIZE8 92);(@repr WORDSIZE8 194);(@repr WORDSIZE8 211);(@repr WORDSIZE8 172);(@repr WORDSIZE8 98);(@repr WORDSIZE8 145);(@repr WORDSIZE8 149);(@repr WORDSIZE8 228);(@repr WORDSIZE8 121);(@repr WORDSIZE8 231);(@repr WORDSIZE8 200);(@repr WORDSIZE8 55);(@repr WORDSIZE8 109);(@repr WORDSIZE8 141);(@repr WORDSIZE8 213);(@repr WORDSIZE8 78);(@repr WORDSIZE8 169);(@repr WORDSIZE8 108);(@repr WORDSIZE8 86);(@repr WORDSIZE8 244);(@repr WORDSIZE8 234);(@repr WORDSIZE8 101);(@repr WORDSIZE8 122);(@repr WORDSIZE8 174);(@repr WORDSIZE8 8);(@repr WORDSIZE8 186);(@repr WORDSIZE8 120);(@repr WORDSIZE8 37);(@repr WORDSIZE8 46);(@repr WORDSIZE8 28);(@repr WORDSIZE8 166);(@repr WORDSIZE8 180);(@repr WORDSIZE8 198);(@repr WORDSIZE8 232);(@repr WORDSIZE8 221);(@repr WORDSIZE8 116);(@repr WORDSIZE8 31);(@repr WORDSIZE8 75);(@repr WORDSIZE8 189);(@repr WORDSIZE8 139);(@repr WORDSIZE8 138);(@repr WORDSIZE8 112);(@repr WORDSIZE8 62);(@repr WORDSIZE8 181);(@repr WORDSIZE8 102);(@repr WORDSIZE8 72);(@repr WORDSIZE8 3);(@repr WORDSIZE8 246);(@repr WORDSIZE8 14);(@repr WORDSIZE8 97);(@repr WORDSIZE8 53);(@repr WORDSIZE8 87);(@repr WORDSIZE8 185);(@repr WORDSIZE8 134);(@repr WORDSIZE8 193);(@repr WORDSIZE8 29);(@repr WORDSIZE8 158);(@repr WORDSIZE8 225);(@repr WORDSIZE8 248);(@repr WORDSIZE8 152);(@repr WORDSIZE8 17);(@repr WORDSIZE8 105);(@repr WORDSIZE8 217);(@repr WORDSIZE8 142);(@repr WORDSIZE8 148);(@repr WORDSIZE8 155);(@repr WORDSIZE8 30);(@repr WORDSIZE8 135);(@repr WORDSIZE8 233);(@repr WORDSIZE8 206);(@repr WORDSIZE8 85);(@repr WORDSIZE8 40);(@repr WORDSIZE8 223);(@repr WORDSIZE8 140);(@repr WORDSIZE8 161);(@repr WORDSIZE8 137);(@repr WORDSIZE8 13);(@repr WORDSIZE8 191);(@repr WORDSIZE8 230);(@repr WORDSIZE8 66);(@repr WORDSIZE8 104);(@repr WORDSIZE8 65);(@repr WORDSIZE8 153);(@repr WORDSIZE8 45);(@repr WORDSIZE8 15);(@repr WORDSIZE8 176);(@repr WORDSIZE8 84);(@repr WORDSIZE8 187);(@repr WORDSIZE8 22)]).

Definition RCON : RCon_t :=
  RCon (array_from_list _ [(@repr WORDSIZE8 141);(@repr WORDSIZE8 1);(@repr WORDSIZE8 2);(@repr WORDSIZE8 4);(@repr WORDSIZE8 8);(@repr WORDSIZE8 16);(@repr WORDSIZE8 32);(@repr WORDSIZE8 64);(@repr WORDSIZE8 128);(@repr WORDSIZE8 27);(@repr WORDSIZE8 54);(@repr WORDSIZE8 108);(@repr WORDSIZE8 216);(@repr WORDSIZE8 171);(@repr WORDSIZE8 77)]).

Definition index_u32 (s : int128) (i : int32) : int32 :=
  (s shift_right (i.*(@repr WORDSIZE32 32))).%((@repr WORDSIZE128 1) shift_left (@repr WORDSIZE32 32)).

Definition index_u8 (s : int32) (i : int32) : int8 :=
  (s shift_right (i.*(@repr WORDSIZE32 8))).%((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 8)).

Definition rebuild_u32 (s0 : int8) (s1 : int8) (s2 : int8) (s3 : int8) : int32 :=
  s0.|((s1 shift_left (@repr WORDSIZE32 8)).|((s2 shift_left (@repr WORDSIZE32 16)).|(s3 shift_left (@repr WORDSIZE32 24)))).

Definition rebuild_u128 (s0 : int32) (s1 : int32) (s2 : int32) (s3 : int32) : int128 :=
  s0.|((s1 shift_left (@repr WORDSIZE32 32)).|((s2 shift_left (@repr WORDSIZE32 64)).|(s3 shift_left (@repr WORDSIZE32 96)))).

Definition subword (v : int32) : int32 :=
  rebuild_u32 (SBOX.[(index_u8 v (@repr WORDSIZE32 0))]) (SBOX.[(index_u8 v (@repr WORDSIZE32 1))]) (SBOX.[(index_u8 v (@repr WORDSIZE32 2))]) (SBOX.[(index_u8 v (@repr WORDSIZE32 3))]).

Definition rotword (v : int32) : int32 :=
  rebuild_u32 (index_u8 v (@repr WORDSIZE32 1)) (index_u8 v (@repr WORDSIZE32 2)) (index_u8 v (@repr WORDSIZE32 3)) (index_u8 v (@repr WORDSIZE32 0)).

Definition vpshufd1 (s : int128) (o : int8) (i : int32) : int32 :=
  index_u32 (s shift_right ((@repr WORDSIZE32 32).*((o shift_right ((@repr WORDSIZE32 2).*i)).%(@repr WORDSIZE8 4)))) (@repr WORDSIZE32 0).

Definition vpshufd (s : int128) (o : int8) : int128 :=
  let d1 := vpshufd1 s o (@repr WORDSIZE32 0) : int32 in
  let d2 := vpshufd1 s o (@repr WORDSIZE32 1) : int32 in
  let d3 := vpshufd1 s o (@repr WORDSIZE32 2) : int32 in
  let d4 := vpshufd1 s o (@repr WORDSIZE32 3) : int32 in
  rebuild_u128 d1 d2 d3 d4.

Definition vshufps (s1 : int128) (s2 : int128) (o : int8) : int128 :=
  let d1 := vpshufd1 s1 o (@repr WORDSIZE32 0) : int32 in
  let d2 := vpshufd1 s1 o (@repr WORDSIZE32 1) : int32 in
  let d3 := vpshufd1 s2 o (@repr WORDSIZE32 2) : int32 in
  let d4 := vpshufd1 s2 o (@repr WORDSIZE32 3) : int32 in
  rebuild_u128 d1 d2 d3 d4.

Definition key_combine (rkey : int128) (temp1 : int128) (temp2 : int128) : (int128 '× int128) :=
  let temp1 := vpshufd temp1 (@repr WORDSIZE8 255) : int128 in
  let temp2 := vshufps temp2 rkey (@repr WORDSIZE8 16) : int128 in
  let rkey := rkey.^temp2 : int128 in
  let temp2 := vshufps temp2 rkey (@repr WORDSIZE8 140) : int128 in
  let rkey := rkey.^temp2 : int128 in
  let rkey := rkey.^temp1 : int128 in
  (rkey,temp2).

Definition aeskeygenassist (v1 : int128) (v2 : int8) : int128 :=
  let x1 := index_u32 v1 (@repr WORDSIZE32 1) : int32 in
  let x3 := index_u32 v1 (@repr WORDSIZE32 3) : int32 in
  let y0 := subword x1 : int32 in
  let y1 := (rotword y0).^v2 : int32 in
  let y2 := subword x3 : int32 in
  let y3 := (rotword y2).^v2 : int32 in
  rebuild_u128 y0 y1 y2 y3.

Definition key_expand (rcon : int8) (rkey : int128) (temp2 : int128) : (int128 '× int128) :=
  let temp1 := aeskeygenassist rkey rcon : int128 in
  key_combine rkey temp1 temp2.

Notation KeyList_t := (Seq_t int128).

Definition keys_expand (key : int128) : Seq_t int128 :=
  let rkeys := new_seq (@repr WORDSIZE32 0) : Seq_t int128 in
  let key := key : int128 in
  let rkeys := push rkeys key : Seq_t int128 in
  let temp2 := (@repr WORDSIZE128 0) : int128 in
  let '(key,rkeys,temp2) := foldi (@repr WORDSIZE32 1) (@repr WORDSIZE32 11) (fun round '(key,rkeys,temp2) =>
      let rcon := RCON.[round] : int8 in
      let '(key_temp,temp2_temp) := key_expand rcon key temp2 : (int128 '× int128) in
      let key := key_temp : int128 in
      let temp2 := temp2_temp : int128 in
      let rkeys := push rkeys key : Seq_t int128 in
      (key,rkeys,temp2)) (key,rkeys,temp2) : (int128 '× Seq_t int128 '× int128) in
  rkeys.

Definition subbytes (s : int128) : int128 :=
  rebuild_u128 (subword (index_u32 s (@repr WORDSIZE32 0))) (subword (index_u32 s (@repr WORDSIZE32 1))) (subword (index_u32 s (@repr WORDSIZE32 2))) (subword (index_u32 s (@repr WORDSIZE32 3))).

Definition matrix_index (s : int128) (i : int32) (j : int32) : int8 :=
  index_u8 (index_u32 s j) i.

Definition shiftrows (s : int128) : int128 :=
  rebuild_u128 (rebuild_u32 (matrix_index s (@repr WORDSIZE32 0) (@repr WORDSIZE32 0)) (matrix_index s (@repr WORDSIZE32 1) (@repr WORDSIZE32 1)) (matrix_index s (@repr WORDSIZE32 2) (@repr WORDSIZE32 2)) (matrix_index s (@repr WORDSIZE32 3) (@repr WORDSIZE32 3))) (rebuild_u32 (matrix_index s (@repr WORDSIZE32 0) (@repr WORDSIZE32 1)) (matrix_index s (@repr WORDSIZE32 1) (@repr WORDSIZE32 2)) (matrix_index s (@repr WORDSIZE32 2) (@repr WORDSIZE32 3)) (matrix_index s (@repr WORDSIZE32 3) (@repr WORDSIZE32 0))) (rebuild_u32 (matrix_index s (@repr WORDSIZE32 0) (@repr WORDSIZE32 2)) (matrix_index s (@repr WORDSIZE32 1) (@repr WORDSIZE32 3)) (matrix_index s (@repr WORDSIZE32 2) (@repr WORDSIZE32 0)) (matrix_index s (@repr WORDSIZE32 3) (@repr WORDSIZE32 1))) (rebuild_u32 (matrix_index s (@repr WORDSIZE32 0) (@repr WORDSIZE32 3)) (matrix_index s (@repr WORDSIZE32 1) (@repr WORDSIZE32 0)) (matrix_index s (@repr WORDSIZE32 2) (@repr WORDSIZE32 1)) (matrix_index s (@repr WORDSIZE32 3) (@repr WORDSIZE32 2))).

Definition xtime (x : int8) : int8 :=
  let x1 := x shift_left (@repr WORDSIZE32 1) : int8 in
  let x7 := x shift_right (@repr WORDSIZE32 7) : int8 in
  let x71 := x7.&(@repr WORDSIZE8 1) : int8 in
  let x711b := x71.*(@repr WORDSIZE8 27) : int8 in
  x1.^x711b.

Definition mixcolumn (c : int32) (state : int128) : int32 :=
  let s0 := matrix_index state (@repr WORDSIZE32 0) c : int8 in
  let s1 := matrix_index state (@repr WORDSIZE32 1) c : int8 in
  let s2 := matrix_index state (@repr WORDSIZE32 2) c : int8 in
  let s3 := matrix_index state (@repr WORDSIZE32 3) c : int8 in
  let tmp := ((s0.^s1).^s2).^s3 : int8 in
  let r0 := (s0.^tmp).^(xtime (s0.^s1)) : int8 in
  let r1 := (s1.^tmp).^(xtime (s1.^s2)) : int8 in
  let r2 := (s2.^tmp).^(xtime (s2.^s3)) : int8 in
  let r3 := (s3.^tmp).^(xtime (s3.^s0)) : int8 in
  rebuild_u32 r0 r1 r2 r3.

Definition mixcolumns (state : int128) : int128 :=
  let c0 := mixcolumn (@repr WORDSIZE32 0) state : int32 in
  let c1 := mixcolumn (@repr WORDSIZE32 1) state : int32 in
  let c2 := mixcolumn (@repr WORDSIZE32 2) state : int32 in
  let c3 := mixcolumn (@repr WORDSIZE32 3) state : int32 in
  rebuild_u128 c0 c1 c2 c3.

Definition aesenc (state : int128) (rkey : int128) : int128 :=
  let state := shiftrows state : int128 in
  let state := subbytes state : int128 in
  let state := mixcolumns state : int128 in
  state.^rkey.

Definition aesenclast (state : int128) (rkey : int128) : int128 :=
  let state := shiftrows state : int128 in
  let state := subbytes state : int128 in
  state.^rkey.

Definition aes_rounds (rkeys : Seq_t int128) (inp : int128) : int128 :=
  let state := inp.^(rkeys.[(@repr WORDSIZE32 0)]) : int128 in
  let state := foldi (@repr WORDSIZE32 1) (@repr WORDSIZE32 10) (fun round state =>
      aesenc state (rkeys.[round])) state : int128 in
  aesenclast state (rkeys.[(@repr WORDSIZE32 10)]).

Definition aes (key : int128) (inp : int128) : int128 :=
  let rkeys := keys_expand key : Seq_t int128 in
  aes_rounds rkeys inp.
