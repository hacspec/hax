(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.

(** Should be moved to Hacspec_Lib.v **)
     Definition int_xI {WS : WORDSIZE} (a : int) : int := MachineIntegers.add (MachineIntegers.mul a (repr 2)) MachineIntegers.one.
Definition int_xO {WS : WORDSIZE} (a : int) : int := MachineIntegers.mul a (repr 2).
Number Notation int Pos.of_num_int Pos.to_num_int (via positive mapping [[int_xI] => xI, [int_xO] => xO , [MachineIntegers.one] => xH]) : hacspec_scope.
Notation "0" := (repr O).
Notation U8_t := int8.
Notation U8 := id.
Notation U16_t := int16.
Notation U16 := id.
Notation U32_t := int32.
Notation U32 := id.
Notation U64_t := int64.
Notation U64 := id.
Notation U128_t := int128.
Notation U128 := id.

Definition array_index {A: Type} `{Default A} {len : nat} (s: nseq A len) {WS} (i : @int WS) := array_index s (unsigned i).
Notation " x .[ a ]" := (array_index x a) (at level 40).
Definition array_upd {A: Type} {len : nat} (s: nseq A len) {WS} (i: @int WS) (new_v: A) : nseq A len := array_upd s (unsigned i) new_v.
Notation " x .[ i ]<- a" := (array_upd x i a) (at level 40).

Class Addition A := add : A -> A -> A.
Notation "a .+ b" := (add a b).
Instance array_add_inst {ws : WORDSIZE} {len: nat} : Addition (nseq (@int ws) len) := { add a b := a array_add b }.
Instance int_add_inst {ws : WORDSIZE} : Addition (@int ws) := { add a b := MachineIntegers.add a b }.

Class Subtraction A := sub : A -> A -> A.
Notation "a .- b" := (sub a b).
Instance array_sub_inst {ws : WORDSIZE} {len: nat} : Subtraction (nseq (@int ws) len) := { sub := array_join_map MachineIntegers.sub }.
Instance int_sub_inst {ws : WORDSIZE} : Subtraction (@int ws) := { sub a b := MachineIntegers.sub a b }.

Class Multiplication A := mul : A -> A -> A.
Notation "a .* b" := (mul a b).
Instance array_mul_inst {ws : WORDSIZE} {len: nat} : Multiplication (nseq (@int ws) len) := { mul a b := a array_mul b }.
Instance int_mul_inst {ws : WORDSIZE} : Multiplication (@int ws) := { mul a b := MachineIntegers.mul a b }.

Class Xor A := xor : A -> A -> A.
Notation "a .^ b" := (xor a b).

Instance array_xor_inst {ws : WORDSIZE} {len: nat} : Xor (nseq (@int ws) len) := { xor a b := a array_xor b }.
Instance int_xor_inst {ws : WORDSIZE} : Xor (@int ws) := { xor a b := MachineIntegers.xor a b }.

Definition new {A : Type} `{Default A} {len} : nseq A len := array_new_ default _.
Class array_or_seq A len :=
{ as_seq : seq A ; as_nseq : nseq A len }.

Arguments as_seq {_} {_} array_or_seq.
Arguments as_nseq {_} {_} array_or_seq.
Coercion as_seq : array_or_seq >-> seq.
Coercion as_nseq : array_or_seq >-> nseq.

Instance nseq_array_or_seq {A len} (a : nseq A len) : array_or_seq A len :=
{ as_seq := array_to_seq a ; as_nseq := a ; }.
Coercion nseq_array_or_seq : nseq >-> array_or_seq.

Instance seq_array_or_seq {A} `{Default A} (a : seq A) : array_or_seq A (length a) :=
{ as_seq := a ; as_nseq := array_from_seq _ a ; }.
Coercion seq_array_or_seq : seq >-> array_or_seq.

Definition update {A : Type}  `{Default A} {len slen} (s : nseq A len) {WS} (start : @int WS) (start_a : array_or_seq A slen) : nseq A len :=
array_update (a := A) (len := len) s (unsigned start) (as_seq start_a).

Definition to_le_U32s {A l} := array_to_le_uint32s (A := A) (l := l).
Axiom to_le_bytes : forall {ws : WORDSIZE} {len}, nseq (@int ws) len -> seq int8.
Definition from_seq {A : Type}  `{Default A} {len slen} (s : array_or_seq A slen) : nseq A len := array_from_seq _ (as_seq s).

Notation Seq_t := seq.
Notation len := (fun s => seq_len s : int32).

Definition array_slice {a: Type} `{Default a} {len : nat} (input: nseq a len) {WS} (start: @int WS) (slice_len: @int WS) : seq a := slice (array_to_seq input) (unsigned start) (unsigned (start .+ slice_len)).
Notation slice := array_slice.
Definition seq_new {A: Type} `{Default A} {WS} (len: @int WS) : seq A := seq_new (unsigned len).
Notation new_seq := seq_new.
Notation num_exact_chunks := seq_num_exact_chunks.
Notation get_exact_chunk := seq_get_exact_chunk.
Definition set_chunk {a: Type} `{Default a} {len} (s: seq a) {WS} (chunk_len: @int WS) (chunk_num: @int WS) (chunk: array_or_seq a len) : seq a := seq_set_chunk s (unsigned chunk_len) (unsigned chunk_num) (as_seq chunk).
Definition set_exact_chunk {a} `{H : Default a} {len} s {WS} := @set_chunk a H len s WS.
     Notation get_remainder_chunk := seq_get_remainder_chunk.
Notation "a <> b" := (negb (eqb a b)).

Notation from_secret_literal := nat_mod_from_secret_literal.
Definition pow2 {m} (x : @int WORDSIZE32) := nat_mod_pow2 m (unsigned x).
Instance nat_mod_addition {n} : Addition (nat_mod n) := { add a b := a +% b }.
Instance nat_mod_subtraction {n} : Subtraction (nat_mod n) := { sub a b := a -% b }.
Instance nat_mod_multiplication {n} : Multiplication (nat_mod n) := { mul a b := a *% b }.
Definition from_slice {a: Type} `{Default a} {len slen} (x : array_or_seq a slen) {WS} (start: @int WS) (slice_len: @int WS) := array_from_slice default len (as_seq x) (unsigned start) (unsigned slice_len).
Notation zero := nat_mod_zero.
Notation to_byte_seq_le := nat_mod_to_byte_seq_le.
Notation U128_to_le_bytes := u128_to_le_bytes.
Notation from_byte_seq_le := nat_mod_from_byte_seq_le.
Definition from_literal {m} := nat_mod_from_literal m.
Notation inv := nat_mod_inv.
Notation update_start := array_update_start.
Notation pow := nat_mod_pow_self.
Notation bit := nat_mod_bit.

Definition int_to_int {ws1 ws2} (i : @int ws1) : @int ws2 := repr (unsigned i).
Coercion int_to_int : int >-> int.
Notation push := seq_push.
Notation Build_secret := secret.
Notation "a -× b" :=
(prod a b) (at level 80, right associativity) : hacspec_scope.
Notation Result_t := (fun '(x,y) => result).
Axiom TODO_name : Type.
Notation ONE := nat_mod_one.
Notation exp := nat_mod_exp.
Notation nat_mod := GZnZ.znz.
Instance nat_mod_znz_addition {n} : Addition (GZnZ.znz n) := { add a b := a +% b }.
Instance nat_mod_znz_subtraction {n} : Subtraction (GZnZ.znz n) := { sub a b := a -% b }.
Instance nat_mod_znz_multiplication {n} : Multiplication (GZnZ.znz n) := { mul a b := a *% b }.
Notation TWO := nat_mod_two.
Notation ne := (fun x y => negb (eqb x y)).
Notation eq := (eqb).
Notation rotate_right := (ror).
Notation to_be_U32s := array_to_be_uint32s.
Notation get_chunk := seq_get_chunk.
Notation num_chunks := seq_num_chunks.
Notation U64_to_be_bytes := uint64_to_be_bytes.
Notation to_be_bytes := array_to_be_bytes.
Notation U8_from_usize := uint8_from_usize.
Notation concat := seq_concat.
Notation declassify := id.
Notation U128_from_be_bytes := uint128_from_be_bytes.
Notation U128_to_be_bytes := uint128_to_be_bytes.
Notation slice_range := array_slice_range.
Notation truncate := seq_truncate.
Axiom array_to_be_uint64s : forall {A l}, nseq A l -> seq uint64.
Notation to_be_U64s := array_to_be_uint64s.
Notation classify := id.
Notation U64_from_U8 := uint64_from_uint8.
(** end of: Should be moved to Hacspec_Lib.v **)


(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Definition BLOCK_SIZE : int32 :=
  (@repr WORDSIZE32 128).

Definition LEN_SIZE : int32 :=
  (@repr WORDSIZE32 16).

Definition K_SIZE : int32 :=
  (@repr WORDSIZE32 80).

Definition HASH_SIZE : int32 :=
  (@repr WORDSIZE32 512)./(@repr WORDSIZE32 8).

Notation Block_t := (nseq int8 BLOCK_SIZE).
Definition Block : Block_t -> Block_t :=
  id.

Notation OpTableType_t := (nseq int32 12).
Definition OpTableType : OpTableType_t -> OpTableType_t :=
  id.

Notation Sha512Digest_t := (nseq int8 HASH_SIZE).
Definition Sha512Digest : Sha512Digest_t -> Sha512Digest_t :=
  id.

Notation RoundConstantsTable_t := (nseq int64 K_SIZE).
Definition RoundConstantsTable : RoundConstantsTable_t -> RoundConstantsTable_t :=
  id.

Notation Hash_t := (nseq int64 8).
Definition Hash : Hash_t -> Hash_t :=
  id.

Definition ch (x : U64_t) (y : U64_t) (z : U64_t) : _ :=
  (x.&y).^((not x).&z).

Definition maj (x : U64_t) (y : U64_t) (z : U64_t) : _ :=
  (x.&y).^((x.&z).^(y.&z)).

Definition OP_TABLE : OpTableType_t :=
  OpTableType (array_from_list _ [(@repr WORDSIZE32 28);(@repr WORDSIZE32 34);(@repr WORDSIZE32 39);(@repr WORDSIZE32 14);(@repr WORDSIZE32 18);(@repr WORDSIZE32 41);(@repr WORDSIZE32 1);(@repr WORDSIZE32 8);(@repr WORDSIZE32 7);(@repr WORDSIZE32 19);(@repr WORDSIZE32 61);(@repr WORDSIZE32 6)]).

Definition K_TABLE : RoundConstantsTable_t :=
  RoundConstantsTable (array_from_list _ [0x428a2f98d728ae22;0x7137449123ef65cd;0xb5c0fbcfec4d3b2f;0xe9b5dba58189dbbc;0x3956c25bf348b538;0x59f111f1b605d019;0x923f82a4af194f9b;0xab1c5ed5da6d8118;0xd807aa98a3030242;0x12835b0145706fbe;0x243185be4ee4b28c;0x550c7dc3d5ffb4e2;0x72be5d74f27b896f;0x80deb1fe3b1696b1;0x9bdc06a725c71235;0xc19bf174cf692694;0xe49b69c19ef14ad2;0xefbe4786384f25e3;0x0fc19dc68b8cd5b5;0x240ca1cc77ac9c65;0x2de92c6f592b0275;0x4a7484aa6ea6e483;0x5cb0a9dcbd41fbd4;0x76f988da831153b5;0x983e5152ee66dfab;0xa831c66d2db43210;0xb00327c898fb213f;0xbf597fc7beef0ee4;0xc6e00bf33da88fc2;0xd5a79147930aa725;0x06ca6351e003826f;0x142929670a0e6e70;0x27b70a8546d22ffc;0x2e1b21385c26c926;0x4d2c6dfc5ac42aed;0x53380d139d95b3df;0x650a73548baf63de;0x766a0abb3c77b2a8;0x81c2c92e47edaee6;0x92722c851482353b;0xa2bfe8a14cf10364;0xa81a664bbc423001;0xc24b8b70d0f89791;0xc76c51a30654be30;0xd192e819d6ef5218;0xd69906245565a910;0xf40e35855771202a;0x106aa07032bbd1b8;0x19a4c116b8d2d0c8;0x1e376c085141ab53;0x2748774cdf8eeb99;0x34b0bcb5e19b48a8;0x391c0cb3c5c95a63;0x4ed8aa4ae3418acb;0x5b9cca4f7763e373;0x682e6ff3d6b2b8a3;0x748f82ee5defb2fc;0x78a5636f43172f60;0x84c87814a1f0ab72;0x8cc702081a6439ec;0x90befffa23631e28;0xa4506cebde82bde9;0xbef9a3f7b2c67915;0xc67178f2e372532b;0xca273eceea26619c;0xd186b8c721c0c207;0xeada7dd6cde0eb1e;0xf57d4f7fee6ed178;0x06f067aa72176fba;0x0a637dc5a2c898a6;0x113f9804bef90dae;0x1b710b35131c471b;0x28db77f523047d84;0x32caab7b40c72493;0x3c9ebe0a15c9bebc;0x431d67c49c100d4c;0x4cc5d4becb3e42b6;0x597f299cfc657e2a;0x5fcb6fab3ad6faec;0x6c44198c4a475817]).

Definition HASH_INIT : Hash_t :=
  Hash (array_from_list _ [0x6a09e667f3bcc908;0xbb67ae8584caa73b;0x3c6ef372fe94f82b;0xa54ff53a5f1d36f1;0x510e527fade682d1;0x9b05688c2b3e6c1f;0x1f83d9abfb41bd6b;0x5be0cd19137e2179]).

Definition sigma (x : U64_t) (i : int32) (op : int32) : U64_t :=
  let tmp := rotate_right x (OP_TABLE.[(((@repr WORDSIZE32 3).*i).+(@repr WORDSIZE32 2))]) : U64_t in
  let tmp := if
      op=.?(@repr WORDSIZE32 0)
    then
      shr x (OP_TABLE.[(((@repr WORDSIZE32 3).*i).+(@repr WORDSIZE32 2))])
    else
      tmp : _ in
  ((rotate_right x (OP_TABLE.[((@repr WORDSIZE32 3).*i)])).^(rotate_right x (OP_TABLE.[(((@repr WORDSIZE32 3).*i).+(@repr WORDSIZE32 1))]))).^tmp.

Definition schedule (block : Block_t) : RoundConstantsTable_t :=
  let b := to_be_U64s block : Seq_t U64_t in
  let s := new : RoundConstantsTable_t in
  foldi (@repr WORDSIZE32 0) K_SIZE (fun i s =>
    if
      i<.?(@repr WORDSIZE32 16)
    then
      s.[i]<-(b.[i])
    else
      let t16 := s.[(i.-(@repr WORDSIZE32 16))] : U64_t in
      let t15 := s.[(i.-(@repr WORDSIZE32 15))] : U64_t in
      let t7 := s.[(i.-(@repr WORDSIZE32 7))] : U64_t in
      let t2 := s.[(i.-(@repr WORDSIZE32 2))] : U64_t in
      let s1 := sigma t2 (@repr WORDSIZE32 3) (@repr WORDSIZE32 0) : U64_t in
      let s0 := sigma t15 (@repr WORDSIZE32 2) (@repr WORDSIZE32 0) : U64_t in
      s.[i]<-(((s1.+t7).+s0).+t16)) s.

Definition shuffle (ws : RoundConstantsTable_t) (hashi : Hash_t) : Hash_t :=
  let h := hashi : Hash_t in
  foldi (@repr WORDSIZE32 0) K_SIZE (fun i h =>
    let a0 := h.[(@repr WORDSIZE32 0)] : U64_t in
    let b0 := h.[(@repr WORDSIZE32 1)] : U64_t in
    let c0 := h.[(@repr WORDSIZE32 2)] : U64_t in
    let d0 := h.[(@repr WORDSIZE32 3)] : U64_t in
    let e0 := h.[(@repr WORDSIZE32 4)] : U64_t in
    let f0 := h.[(@repr WORDSIZE32 5)] : U64_t in
    let g0 := h.[(@repr WORDSIZE32 6)] : U64_t in
    let h0 := h.[(@repr WORDSIZE32 7)] : U64_t in
    let t1 := (((h0.+(sigma e0 (@repr WORDSIZE32 1) (@repr WORDSIZE32 1))).+(ch e0 f0 g0)).+(K_TABLE.[i])).+(ws.[i]) : U64_t in
    let t2 := (sigma a0 (@repr WORDSIZE32 0) (@repr WORDSIZE32 1)).+(maj a0 b0 c0) : U64_t in
    let h := h.[(@repr WORDSIZE32 0)]<-(t1.+t2) : Hash_t in
    let h := h.[(@repr WORDSIZE32 1)]<-a0 : Hash_t in
    let h := h.[(@repr WORDSIZE32 2)]<-b0 : Hash_t in
    let h := h.[(@repr WORDSIZE32 3)]<-c0 : Hash_t in
    let h := h.[(@repr WORDSIZE32 4)]<-(d0.+t1) : Hash_t in
    let h := h.[(@repr WORDSIZE32 5)]<-e0 : Hash_t in
    let h := h.[(@repr WORDSIZE32 6)]<-f0 : Hash_t in
    h.[(@repr WORDSIZE32 7)]<-g0) h.

Definition compress (block : Block_t) (h_in : Hash_t) : Hash_t :=
  let s := schedule block : RoundConstantsTable_t in
  let h := shuffle s h_in : Hash_t in
  foldi (@repr WORDSIZE32 0) (@repr WORDSIZE32 8) (fun i h =>
    h.[i]<-((h.[i]).+(h_in.[i]))) h.

Definition hash (msg : Seq_t U8_t) : Sha512Digest_t :=
  let h := HASH_INIT : Hash_t in
  let last_block := new : Block_t in
  let last_block_len := (@repr WORDSIZE32 0) : int32 in
  let '(h,last_block,last_block_len) := foldi (@repr WORDSIZE32 0) (num_chunks msg BLOCK_SIZE) (fun i '(h,last_block,last_block_len) =>
      let '(block_len,block) := get_chunk msg BLOCK_SIZE i : (int32 '× Seq_t U8_t) in
      if
        block_len<.?BLOCK_SIZE
      then
        let last_block := update_start new block : Block_t in
        let last_block_len := block_len : int32 in
        (h,last_block,last_block_len)
      else
        let compress_input := from_seq block : Block_t in
        let h := compress compress_input h : Hash_t in
        (h,last_block,last_block_len)) (h,last_block,last_block_len) : (Hash_t '× Block_t '× int32) in
  let last_block := last_block.[last_block_len]<-(secret (@repr WORDSIZE8 128)) : Block_t in
  let len_bist := secret ((len msg).*(@repr WORDSIZE32 8)) : U128_t in
  let '(h,last_block) := if
      last_block_len<.?(BLOCK_SIZE.-LEN_SIZE)
    then
      let last_block := update last_block (BLOCK_SIZE.-LEN_SIZE) (U128_to_be_bytes len_bist) : Block_t in
      let h := compress last_block h : Hash_t in
      (h,last_block)
    else
      let pad_block := new : Block_t in
      let pad_block := update pad_block (BLOCK_SIZE.-LEN_SIZE) (U128_to_be_bytes len_bist) : Block_t in
      let h := compress last_block h : Hash_t in
      let h := compress pad_block h : Hash_t in
      (h,last_block) : (Hash_t '× Block_t) in
  from_seq (to_be_bytes h).

Definition sha512 (msg : Seq_t U8_t) : Sha512Digest_t :=
  hash msg.
