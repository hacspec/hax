(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Open Scope hacspec_scope.

(** Should be moved to Hacspec_Lib.v **)
     Definition int_xI {WS : WORDSIZE} (a : int) : int := MachineIntegers.add (MachineIntegers.mul a (repr 2)) MachineIntegers.one.
Definition int_xO {WS : WORDSIZE} (a : int) : int := MachineIntegers.mul a (repr 2).
Number Notation int Pos.of_num_int Pos.to_num_int (via positive mapping [[int_xI] => xI, [int_xO] => xO , [MachineIntegers.one] => xH]) : hacspec_scope.
Notation "0" := (repr O).
Notation U8_t := int8.
Notation U8 := id.
Notation U16_t := int16.
Notation U16 := id.
Notation U32_t := int32.
Notation U32 := id.
Notation U64_t := int64.
Notation U64 := id.
Notation U128_t := int128.
Notation U128 := id.

Definition array_index {A: Type} `{Default A} {len : nat} (s: nseq A len) {WS} (i : @int WS) := array_index s (unsigned i).
Notation " x .[ a ]" := (array_index x a) (at level 40).
Definition array_upd {A: Type} {len : nat} (s: nseq A len) {WS} (i: @int WS) (new_v: A) : nseq A len := array_upd s (unsigned i) new_v.
Notation " x .[ i ]<- a" := (array_upd x i a) (at level 40).

Class Addition A := add : A -> A -> A.
Notation "a .+ b" := (add a b).
Instance array_add_inst {ws : WORDSIZE} {len: nat} : Addition (nseq (@int ws) len) := { add a b := a array_add b }.
Instance int_add_inst {ws : WORDSIZE} : Addition (@int ws) := { add a b := MachineIntegers.add a b }.

Class Subtraction A := sub : A -> A -> A.
Notation "a .- b" := (sub a b).
Instance array_sub_inst {ws : WORDSIZE} {len: nat} : Subtraction (nseq (@int ws) len) := { sub := array_join_map MachineIntegers.sub }.
Instance int_sub_inst {ws : WORDSIZE} : Subtraction (@int ws) := { sub a b := MachineIntegers.sub a b }.

Class Multiplication A := mul : A -> A -> A.
Notation "a .* b" := (mul a b).
Instance array_mul_inst {ws : WORDSIZE} {len: nat} : Multiplication (nseq (@int ws) len) := { mul a b := a array_mul b }.
Instance int_mul_inst {ws : WORDSIZE} : Multiplication (@int ws) := { mul a b := MachineIntegers.mul a b }.

Class Xor A := xor : A -> A -> A.
Notation "a .^ b" := (xor a b).

Instance array_xor_inst {ws : WORDSIZE} {len: nat} : Xor (nseq (@int ws) len) := { xor a b := a array_xor b }.
Instance int_xor_inst {ws : WORDSIZE} : Xor (@int ws) := { xor a b := MachineIntegers.xor a b }.

Definition new {A : Type} `{Default A} {len} : nseq A len := array_new_ default _.
Class array_or_seq A len :=
{ as_seq : seq A ; as_nseq : nseq A len }.

Arguments as_seq {_} {_} array_or_seq.
Arguments as_nseq {_} {_} array_or_seq.
Coercion as_seq : array_or_seq >-> seq.
Coercion as_nseq : array_or_seq >-> nseq.

Instance nseq_array_or_seq {A len} (a : nseq A len) : array_or_seq A len :=
{ as_seq := array_to_seq a ; as_nseq := a ; }.
Coercion nseq_array_or_seq : nseq >-> array_or_seq.

Instance seq_array_or_seq {A} `{Default A} (a : seq A) : array_or_seq A (length a) :=
{ as_seq := a ; as_nseq := array_from_seq _ a ; }.
Coercion seq_array_or_seq : seq >-> array_or_seq.

Definition update {A : Type}  `{Default A} {len slen} (s : nseq A len) {WS} (start : @int WS) (start_a : array_or_seq A slen) : nseq A len :=
array_update (a := A) (len := len) s (unsigned start) (as_seq start_a).

Definition to_le_U32s {A l} := array_to_le_uint32s (A := A) (l := l).
Axiom to_le_bytes : forall {ws : WORDSIZE} {len}, nseq (@int ws) len -> seq int8.
Definition from_seq {A : Type}  `{Default A} {len slen} (s : array_or_seq A slen) : nseq A len := array_from_seq _ (as_seq s).

Notation Seq_t := seq.
Notation len := (fun s => seq_len s : int32).

Definition array_slice {a: Type} `{Default a} {len : nat} (input: nseq a len) {WS} (start: @int WS) (slice_len: @int WS) : seq a := slice (array_to_seq input) (unsigned start) (unsigned (start .+ slice_len)).
Notation slice := array_slice.
Definition seq_new {A: Type} `{Default A} {WS} (len: @int WS) : seq A := seq_new (unsigned len).
Notation new_seq := seq_new.
Notation num_exact_chunks := seq_num_exact_chunks.
Notation get_exact_chunk := seq_get_exact_chunk.
Definition set_chunk {a: Type} `{Default a} {len} (s: seq a) {WS} (chunk_len: @int WS) (chunk_num: @int WS) (chunk: array_or_seq a len) : seq a := seq_set_chunk s (unsigned chunk_len) (unsigned chunk_num) (as_seq chunk).
Definition set_exact_chunk {a} `{H : Default a} {len} s {WS} := @set_chunk a H len s WS.
     Notation get_remainder_chunk := seq_get_remainder_chunk.
Notation "a <> b" := (negb (eqb a b)).

Notation from_secret_literal := nat_mod_from_secret_literal.
Definition pow2 {m} (x : @int WORDSIZE32) := nat_mod_pow2 m (unsigned x).
Instance nat_mod_addition {n} : Addition (nat_mod n) := { add a b := a +% b }.
Instance nat_mod_subtraction {n} : Subtraction (nat_mod n) := { sub a b := a -% b }.
Instance nat_mod_multiplication {n} : Multiplication (nat_mod n) := { mul a b := a *% b }.
Definition from_slice {a: Type} `{Default a} {len slen} (x : array_or_seq a slen) {WS} (start: @int WS) (slice_len: @int WS) := array_from_slice default len (as_seq x) (unsigned start) (unsigned slice_len).
Notation zero := nat_mod_zero.
Notation to_byte_seq_le := nat_mod_to_byte_seq_le.
Notation U128_to_le_bytes := u128_to_le_bytes.
Notation from_byte_seq_le := nat_mod_from_byte_seq_le.
Definition from_literal {m} := nat_mod_from_literal m.
Notation inv := nat_mod_inv.
Notation update_start := array_update_start.
Notation pow := nat_mod_pow_self.
Notation bit := nat_mod_bit.

Definition int_to_int {ws1 ws2} (i : @int ws1) : @int ws2 := repr (unsigned i).
Coercion int_to_int : int >-> int.
Notation push := seq_push.
Notation Build_secret := secret.
Notation "a -× b" :=
(prod a b) (at level 80, right associativity) : hacspec_scope.
Notation Result_t := (fun '(x,y) => result).
Axiom TODO_name : Type.
Notation ONE := nat_mod_one.
Notation exp := nat_mod_exp.
Notation nat_mod := GZnZ.znz.
Instance nat_mod_znz_addition {n} : Addition (GZnZ.znz n) := { add a b := a +% b }.
Instance nat_mod_znz_subtraction {n} : Subtraction (GZnZ.znz n) := { sub a b := a -% b }.
Instance nat_mod_znz_multiplication {n} : Multiplication (GZnZ.znz n) := { mul a b := a *% b }.
Notation TWO := nat_mod_two.
Notation ne := (fun x y => negb (eqb x y)).
Notation eq := (eqb).
Notation rotate_right := (ror).
Notation to_be_U32s := array_to_be_uint32s.
Notation get_chunk := seq_get_chunk.
Notation num_chunks := seq_num_chunks.
Notation U64_to_be_bytes := uint64_to_be_bytes.
Notation to_be_bytes := array_to_be_bytes.
Notation U8_from_usize := uint8_from_usize.
Notation concat := seq_concat.
Notation declassify := id.
Notation U128_from_be_bytes := uint128_from_be_bytes.
Notation U128_to_be_bytes := uint128_to_be_bytes.
Notation slice_range := array_slice_range.
Notation truncate := seq_truncate.
Axiom array_to_be_uint64s : forall {A l}, nseq A l -> seq uint64.
Notation to_be_U64s := array_to_be_uint64s.
Notation classify := id.
Notation U64_from_U8 := uint64_from_uint8.
(** end of: Should be moved to Hacspec_Lib.v **)


(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Notation State_t := (nseq int32 12).
Definition State : State_t -> State_t :=
  id.

Definition swap (s : State_t) (i : int32) (j : int32) : State_t :=
  let tmp := s.[i] : U32_t in
  let s := s.[i]<-(s.[j]) : State_t in
  let s := s.[j]<-tmp : State_t in
  s.

Definition gimli_round (s : State_t) (r : int32) : State_t :=
  let s := foldi (@repr WORDSIZE32 0) (@repr WORDSIZE32 4) (fun col s =>
      let x := rol (s.[col]) (@repr WORDSIZE32 24) : U32_t in
      let y := rol (s.[(col.+(@repr WORDSIZE32 4))]) (@repr WORDSIZE32 9) : U32_t in
      let z := s.[(col.+(@repr WORDSIZE32 8))] : U32_t in
      let s := s.[(col.+(@repr WORDSIZE32 8))]<-((x.^(shl z (@repr WORDSIZE32 1))).^(shl (y.&z) (@repr WORDSIZE32 2))) : State_t in
      let s := s.[(col.+(@repr WORDSIZE32 4))]<-((y.^x).^(shl (x.|z) (@repr WORDSIZE32 1))) : State_t in
      s.[col]<-((z.^y).^(shl (x.&y) (@repr WORDSIZE32 3)))) s : State_t in
  let s := if
      (r.&(@repr WORDSIZE32 3))=.?(@repr WORDSIZE32 0)
    then
      let s := swap s (@repr WORDSIZE32 0) (@repr WORDSIZE32 1) : State_t in
      swap s (@repr WORDSIZE32 2) (@repr WORDSIZE32 3)
    else
      s : State_t in
  let s := if
      (r.&(@repr WORDSIZE32 3))=.?(@repr WORDSIZE32 2)
    then
      let s := swap s (@repr WORDSIZE32 0) (@repr WORDSIZE32 2) : State_t in
      swap s (@repr WORDSIZE32 1) (@repr WORDSIZE32 3)
    else
      s : State_t in
  let s := if
      (r.&(@repr WORDSIZE32 3))=.?(@repr WORDSIZE32 0)
    then
      s.[(@repr WORDSIZE32 0)]<-((s.[(@repr WORDSIZE32 0)]).^((secret (@repr WORDSIZE32 2654435584)).|(secret r)))
    else
      s : _ in
  s.

Definition gimli (s : State_t) : State_t :=
  let s := foldi (@repr WORDSIZE32 0) (@repr WORDSIZE32 24) (fun rnd s =>
      let rnd := (@repr WORDSIZE32 24).-rnd : int32 in
      gimli_round s rnd) s : State_t in
  s.

Notation Block_t := (nseq int8 16).
Definition Block : Block_t -> Block_t :=
  id.

Notation Digest_t := (nseq int8 32).
Definition Digest : Digest_t -> Digest_t :=
  id.

Definition absorb_block (input_block : Block_t) (s : State_t) : State_t :=
  let input_bytes := to_le_U32s input_block : Seq_t U32_t in
  let s := s.[(@repr WORDSIZE32 0)]<-((s.[(@repr WORDSIZE32 0)]).^(input_bytes.[(@repr WORDSIZE32 0)])) : State_t in
  let s := s.[(@repr WORDSIZE32 1)]<-((s.[(@repr WORDSIZE32 1)]).^(input_bytes.[(@repr WORDSIZE32 1)])) : State_t in
  let s := s.[(@repr WORDSIZE32 2)]<-((s.[(@repr WORDSIZE32 2)]).^(input_bytes.[(@repr WORDSIZE32 2)])) : State_t in
  let s := s.[(@repr WORDSIZE32 3)]<-((s.[(@repr WORDSIZE32 3)]).^(input_bytes.[(@repr WORDSIZE32 3)])) : State_t in
  gimli s.

Definition squeeze_block (s : State_t) : Block_t :=
  let block := new : Block_t in
  foldi (@repr WORDSIZE32 0) (@repr WORDSIZE32 4) (fun i block =>
    let s_i := s.[i] : U32_t in
    let s_i_bytes := to_le_bytes s_i : Seq_t U8_t in
    let block := block.[((@repr WORDSIZE32 4).*i)]<-(s_i_bytes.[(@repr WORDSIZE32 0)]) : Block_t in
    let block := block.[(((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 1))]<-(s_i_bytes.[(@repr WORDSIZE32 1)]) : Block_t in
    let block := block.[(((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 2))]<-(s_i_bytes.[(@repr WORDSIZE32 2)]) : Block_t in
    block.[(((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 3))]<-(s_i_bytes.[(@repr WORDSIZE32 3)])) block.

Definition gimli_hash_state (input : Seq_t U8_t) (s : State_t) : State_t :=
  let rate := length : int32 in
  let chunks := num_exact_chunks input rate : int32 in
  let s := foldi (@repr WORDSIZE32 0) chunks (fun i s =>
      let input_block := get_exact_chunk input rate i : Seq_t U8_t in
      let full_block := from_seq input_block : Block_t in
      absorb_block full_block s) s : State_t in
  let input_block := get_remainder_chunk input rate : Seq_t U8_t in
  let input_block_padded := new : Block_t in
  let input_block_padded := update_start input_block_padded input_block : Block_t in
  let input_block_padded := input_block_padded.[(len input_block)]<-(secret (@repr WORDSIZE8 1)) : Block_t in
  let s := s.[(@repr WORDSIZE32 11)]<-((s.[(@repr WORDSIZE32 11)]).^(secret (@repr WORDSIZE32 16777216))) : State_t in
  let s := absorb_block input_block_padded s : State_t in
  s.

Definition gimli_hash (input_bytes : Seq_t U8_t) : Digest_t :=
  let s := new : State_t in
  let s := gimli_hash_state input_bytes s : State_t in
  let output := new : Digest_t in
  let output := update_start output (squeeze_block s) : Digest_t in
  let s := gimli s : State_t in
  update output length (squeeze_block s).

Notation Nonce_t := (nseq int8 16).
Definition Nonce : Nonce_t -> Nonce_t :=
  id.

Notation Key_t := (nseq int8 32).
Definition Key : Key_t -> Key_t :=
  id.

Notation Tag_t := (nseq int8 16).
Definition Tag : Tag_t -> Tag_t :=
  id.

Definition process_ad (ad : Seq_t U8_t) (s : State_t) : State_t :=
  gimli_hash_state ad s.

Definition process_msg (message : Seq_t U8_t) (s : State_t) : (State_t '× Seq_t U8_t) :=
  let ciphertext := new_seq (len message) : Seq_t U8_t in
  let rate := length : int32 in
  let num_chunks := num_exact_chunks message rate : int32 in
  let '(ciphertext,s) := foldi (@repr WORDSIZE32 0) num_chunks (fun i '(ciphertext,s) =>
      let key_block := squeeze_block s : Block_t in
      let msg_block := get_exact_chunk message rate i : Seq_t U8_t in
      let msg_block := from_seq msg_block : Block_t in
      let ciphertext := set_exact_chunk ciphertext rate i (msg_block.^key_block) : Seq_t U8_t in
      let s := absorb_block msg_block s : State_t in
      (ciphertext,s)) (ciphertext,s) : (Seq_t U8_t '× State_t) in
  let key_block := squeeze_block s : Block_t in
  let last_block := get_remainder_chunk message rate : Seq_t U8_t in
  let block_len := len last_block : int32 in
  let msg_block_padded := new : Block_t in
  let msg_block_padded := update_start msg_block_padded last_block : Block_t in
  let ciphertext := set_chunk ciphertext rate num_chunks (slice_range (msg_block_padded.^key_block) (Build_Range_t (@repr WORDSIZE32 0)block_len)) : Seq_t U8_t in
  let msg_block_padded := msg_block_padded.[block_len]<-((msg_block_padded.[block_len]).^(secret (@repr WORDSIZE8 1))) : Block_t in
  let s := s.[(@repr WORDSIZE32 11)]<-((s.[(@repr WORDSIZE32 11)]).^(secret (@repr WORDSIZE32 16777216))) : State_t in
  let s := absorb_block msg_block_padded s : State_t in
  (s,ciphertext).

Definition process_ct (ciphertext : Seq_t U8_t) (s : State_t) : (State_t '× Seq_t U8_t) :=
  let message := new_seq (len ciphertext) : Seq_t U8_t in
  let rate := length : int32 in
  let num_chunks := num_exact_chunks ciphertext rate : int32 in
  let '(message,s) := foldi (@repr WORDSIZE32 0) num_chunks (fun i '(message,s) =>
      let key_block := squeeze_block s : Block_t in
      let ct_block := get_exact_chunk ciphertext rate i : Seq_t U8_t in
      let ct_block := from_seq ct_block : Block_t in
      let msg_block := ct_block.^key_block : Block_t in
      let message := set_exact_chunk message rate i (ct_block.^key_block) : Seq_t U8_t in
      let s := absorb_block msg_block s : State_t in
      (message,s)) (message,s) : (Seq_t U8_t '× State_t) in
  let key_block := squeeze_block s : Block_t in
  let ct_final := get_remainder_chunk ciphertext rate : Seq_t U8_t in
  let block_len := len ct_final : int32 in
  let ct_block_padded := new : Block_t in
  let ct_block_padded := update_start ct_block_padded ct_final : Block_t in
  let msg_block := ct_block_padded.^key_block : Block_t in
  let message := set_chunk message rate num_chunks (slice_range msg_block (Build_Range_t (@repr WORDSIZE32 0)block_len)) : Seq_t U8_t in
  let msg_block := from_slice_range msg_block (Build_Range_t (@repr WORDSIZE32 0)block_len) : Block_t in
  let msg_block := msg_block.[block_len]<-((msg_block.[block_len]).^(secret (@repr WORDSIZE8 1))) : Block_t in
  let s := s.[(@repr WORDSIZE32 11)]<-((s.[(@repr WORDSIZE32 11)]).^(secret (@repr WORDSIZE32 16777216))) : State_t in
  let s := absorb_block msg_block s : State_t in
  (s,message).

Definition nonce_to_u32s (nonce : Nonce_t) : Seq_t U32_t :=
  let uints := new_seq (@repr WORDSIZE32 4) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 0)]<-(U32_from_le_bytes (from_slice_range nonce (Build_Range_t (@repr WORDSIZE32 0)(@repr WORDSIZE32 4)))) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 1)]<-(U32_from_le_bytes (from_slice_range nonce (Build_Range_t (@repr WORDSIZE32 4)(@repr WORDSIZE32 8)))) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 2)]<-(U32_from_le_bytes (from_slice_range nonce (Build_Range_t (@repr WORDSIZE32 8)(@repr WORDSIZE32 12)))) : Seq_t U32_t in
  uints.[(@repr WORDSIZE32 3)]<-(U32_from_le_bytes (from_slice_range nonce (Build_Range_t (@repr WORDSIZE32 12)(@repr WORDSIZE32 16)))).

Definition key_to_u32s (key : Key_t) : Seq_t U32_t :=
  let uints := new_seq (@repr WORDSIZE32 8) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 0)]<-(U32_from_le_bytes (from_slice_range key (Build_Range_t (@repr WORDSIZE32 0)(@repr WORDSIZE32 4)))) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 1)]<-(U32_from_le_bytes (from_slice_range key (Build_Range_t (@repr WORDSIZE32 4)(@repr WORDSIZE32 8)))) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 2)]<-(U32_from_le_bytes (from_slice_range key (Build_Range_t (@repr WORDSIZE32 8)(@repr WORDSIZE32 12)))) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 3)]<-(U32_from_le_bytes (from_slice_range key (Build_Range_t (@repr WORDSIZE32 12)(@repr WORDSIZE32 16)))) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 4)]<-(U32_from_le_bytes (from_slice_range key (Build_Range_t (@repr WORDSIZE32 16)(@repr WORDSIZE32 20)))) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 5)]<-(U32_from_le_bytes (from_slice_range key (Build_Range_t (@repr WORDSIZE32 20)(@repr WORDSIZE32 24)))) : Seq_t U32_t in
  let uints := uints.[(@repr WORDSIZE32 6)]<-(U32_from_le_bytes (from_slice_range key (Build_Range_t (@repr WORDSIZE32 24)(@repr WORDSIZE32 28)))) : Seq_t U32_t in
  uints.[(@repr WORDSIZE32 7)]<-(U32_from_le_bytes (from_slice_range key (Build_Range_t (@repr WORDSIZE32 28)(@repr WORDSIZE32 32)))).

Definition gimli_aead_encrypt (message : Seq_t U8_t) (ad : Seq_t U8_t) (nonce : Nonce_t) (key : Key_t) : (Seq_t U8_t '× Tag_t) :=
  let s := from_seq (concat (nonce_to_u32s nonce) (key_to_u32s key)) : State_t in
  let s := gimli s : State_t in
  let s := process_ad ad s : State_t in
  let '(s,ciphertext) := process_msg message s : (State_t '× Seq_t U8_t) in
  let tag := squeeze_block s : Block_t in
  let tag := from_seq tag : Tag_t in
  (ciphertext,tag).

Definition gimli_aead_decrypt (ciphertext : Seq_t U8_t) (ad : Seq_t U8_t) (tag : Tag_t) (nonce : Nonce_t) (key : Key_t) : Seq_t U8_t :=
  let s := from_seq (concat (nonce_to_u32s nonce) (key_to_u32s key)) : State_t in
  let s := gimli s : State_t in
  let s := process_ad ad s : State_t in
  let '(s,message) := process_ct ciphertext s : (State_t '× Seq_t U8_t) in
  let my_tag := squeeze_block s : Block_t in
  let my_tag := from_seq my_tag : Tag_t in
  let out := new_seq (@repr WORDSIZE32 0) : Seq_t U8_t in
  if
    equal my_tag tag
  then
    message
  else
    out.
