---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: ssprove
  info:
    name: enum-repr
    manifest: enum-repr/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = '''
Compiling enum-repr v0.1.0 (WORKSPACE_ROOT/enum-repr)
    Finished dev [unoptimized + debuginfo] target(s) in XXs'''

[stdout]
diagnostics = []

[stdout.files]
"Enum_repr.v" = '''
(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Equations discriminant_Foo_A {L : {fset Location}} {I : Interface} : both L I int16 :=
  discriminant_Foo_A  :=
    solve_lift (ret_both (1 : int16)) : both L I int16.
Fail Next Obligation.

Equations discriminant_Foo_B {L : {fset Location}} {I : Interface} : both L I int16 :=
  discriminant_Foo_B  :=
    solve_lift (ret_both (5 : int16)) : both L I int16.
Fail Next Obligation.

Definition t_Foo : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'Foo_A_case'" := (inl (inl (inl tt))) (at level 100).
Equations Foo_A {L : {fset Location}} {I : Interface} : both L I t_Foo :=
  Foo_A  :=
    solve_lift (ret_both (inl (inl (inl (tt : 'unit))) : t_Foo)) : both L I t_Foo.
Fail Next Obligation.
Notation "'Foo_B_case'" := (inl (inl (inr tt))) (at level 100).
Equations Foo_B {L : {fset Location}} {I : Interface} : both L I t_Foo :=
  Foo_B  :=
    solve_lift (ret_both (inl (inl (inr (tt : 'unit))) : t_Foo)) : both L I t_Foo.
Fail Next Obligation.
Notation "'Foo_C_case'" := (inl (inr tt)) (at level 100).
Equations Foo_C {L : {fset Location}} {I : Interface} : both L I t_Foo :=
  Foo_C  :=
    solve_lift (ret_both (inl (inr (tt : 'unit)) : t_Foo)) : both L I t_Foo.
Fail Next Obligation.
Notation "'Foo_D_case'" := (inr tt) (at level 100).
Equations Foo_D {L : {fset Location}} {I : Interface} : both L I t_Foo :=
  Foo_D  :=
    solve_lift (ret_both (inr (tt : 'unit) : t_Foo)) : both L I t_Foo.
Fail Next Obligation.

Equations t_Foo_cast_to_repr {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 t_Foo) : both L1 I1 int16 :=
  t_Foo_cast_to_repr x  :=
    matchb x with
    | Foo_A_case  =>
      solve_lift discriminant_Foo_A
    | Foo_B_case  =>
      solve_lift discriminant_Foo_B
    | Foo_C_case  =>
      solve_lift (discriminant_Foo_B .+ (ret_both (1 : int16)))
    | Foo_D_case  =>
      solve_lift (discriminant_Foo_B .+ (ret_both (2 : int16)))
    end : both L1 I1 int16.
Fail Next Obligation.

(*Not implemented yet? todo(item)*)

Equations f {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 'unit) : both L1 I1 int16 :=
  f _  :=
    letb v__x := cast_int (WS2 := _) (discriminant_Foo_B .+ (ret_both (0 : int16))) in
    solve_lift (cast_int (WS2 := _) v_C) : both L1 I1 int16.
Fail Next Obligation.

Equations ff__CONST {L : {fset Location}} {I : Interface} : both L I int16 :=
  ff__CONST  :=
    solve_lift (cast_int (WS2 := _) (discriminant_Foo_A .+ (ret_both (0 : int16)))) : both L I int16.
Fail Next Obligation.

Equations get_casted_repr {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 t_Foo) : both L1 I1 int64 :=
  get_casted_repr x  :=
    solve_lift (cast_int (WS2 := _) (t_Foo_cast_to_repr x)) : both L1 I1 int64.
Fail Next Obligation.

Equations get_repr {L1 : {fset Location}} {I1 : Interface} (x : both L1 I1 t_Foo) : both L1 I1 int16 :=
  get_repr x  :=
    solve_lift (t_Foo_cast_to_repr x) : both L1 I1 int16.
Fail Next Obligation.
'''
