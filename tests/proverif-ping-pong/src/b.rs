use hax_lib_protocol::{state_machine::*, ProtocolError, ProtocolResult};

use crate::Message;

// ==== B states ====
pub struct B0 {}

pub struct B1 {
    received: u8,
}

// An alternative successor of B0 to show read alternatives
pub struct B1alt {}

pub struct B2 {}

// ==== B initialization ====
#[hax_lib_protocol_macros::init_empty(B0)]
fn init_b() -> ProtocolResult<B0> {
    Ok(B0 {})
}

// The following generated by macro:
// #[hax_lib_macros::exclude]
// impl InitialState for B0 {
//     fn init(prologue: Option<Vec<u8>>) -> ProtocolResult<Self> {
//         if let Some(_) = prologue {
//             Err(ProtocolError::InvalidPrologue)
//         } else {
//             init_b()
//         }
//     }
// }

// ==== B state transistion functions ====
#[hax_lib_protocol_macros::read(B0, B1, Message)]
fn read_ping(_state: B0, msg: Message) -> ProtocolResult<B1> {
    match msg {
        Message::Ping(received) => Ok(B1 { received }),
        Message::Pong(_) => Err(ProtocolError::InvalidMessage),
    }
}

// The following generated by macro:
/*#[hax_lib_macros::exclude]
impl TryFrom<(B0, Message)> for B1 {
    type Error = ProtocolError;

    fn try_from((state, msg): (B0, Message)) -> Result<Self, Self::Error> {
        read_ping(state, msg)
    }
}

#[hax_lib_macros::exclude]
impl ReadState<B1> for B0 {
    type Message = Message;
    fn read(self, msg: Message) -> Result<B1, ProtocolError> {
        B1::try_from((self, msg))
    }
}*/

#[hax_lib_protocol_macros::read(B0, B1alt, Message)]
fn read_ping_alt(_state: B0, msg: Message) -> ProtocolResult<B1alt> {
    match msg {
        Message::Ping(received) if received == 42 => Ok(B1alt {}),
        _ => Err(ProtocolError::InvalidMessage),
    }
}

// The following generated by macro:
/*#[hax_lib_macros::exclude]
impl TryFrom<(B0, Message)> for B1alt {
    type Error = ProtocolError;

    fn try_from((state, msg): (B0, Message)) -> Result<Self, Self::Error> {
        read_ping_alt(state, msg)
    }
}

#[hax_lib_macros::exclude]
impl ReadState<B1alt> for B0 {
    type Message = Message;
    fn read(self, msg: Message) -> Result<B1alt, ProtocolError> {
        B1alt::try_from((self, msg))
    }
}*/

#[hax_lib_protocol_macros::write(B1, B2, Message)]
fn write_pong(state: B1) -> ProtocolResult<(B2, Message)> {
    Ok((B2 {}, Message::Pong(state.received)))
}

// The following generated by macro:
/*#[hax_lib_macros::exclude]
impl TryFrom<B1> for (B2, Message) {
    type Error = ProtocolError;

    fn try_from(value: B1) -> Result<Self, Self::Error> {
        write_pong(value)
    }
}

#[hax_lib_macros::exclude]
impl WriteState for B1 {
    type Message = Message;
    type NextState = B2;

    fn write(self) -> Result<(Self::NextState, Message), ProtocolError> {
        self.try_into()
    }
}*/
