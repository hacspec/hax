use hax_lib_protocol::{state_machine::*, ProtocolError, ProtocolResult};

use crate::Message;

// ==== A states ====
pub struct A0 {
    data: u8,
}

pub struct A1 {}

pub struct A2 {
    #[allow(dead_code)]
    received: u8,
}

// ==== A initialization ====
#[hax_lib_protocol_macros::init(A0)]
fn init_a(prologue: Vec<u8>) -> ProtocolResult<A0> {
    if prologue.len() < 1 {
        Err(ProtocolError::InvalidPrologue)
    } else {
        Ok(A0 { data: prologue[0] })
    }
}

// The following generated by macro:
/* #[hax_lib_macros::exclude]
impl TryFrom<Vec<u8>> for A0 {
    type Error = ProtocolError;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        init_a(value)
    }
}

#[hax_lib_macros::exclude]
impl InitialState for A0 {
    fn init(prologue: Option<Vec<u8>>) -> ProtocolResult<Self> {
        if let Some(prologue) = prologue {
            prologue.try_into()
        } else {
            Err(ProtocolError::InvalidPrologue)
        }
    }
} */

// ==== A state transistion functions ====
#[hax_lib_protocol_macros::write(A0, A1, Message)]
fn write_ping(state: A0) -> ProtocolResult<(A1, Message)> {
    Ok((A1 {}, Message::Ping(state.data)))
}

// The following generated by macro:
/*#[hax_lib_macros::exclude]
impl TryFrom<A0> for (A1, Message) {
    type Error = ProtocolError;

    fn try_from(value: A0) -> Result<Self, Self::Error> {
        write_ping(value)
    }
}

#[hax_lib_macros::exclude]
impl WriteState for A0 {
    type NextState = A1;
    type Message = Message;

    fn write(self) -> ProtocolResult<(Self::NextState, Message)> {
        self.try_into()
    }
}*/

#[hax_lib_protocol_macros::read(A1, A2, Message)]
fn read_pong(_state: A1, msg: Message) -> ProtocolResult<A2> {
    match msg {
        Message::Ping(_) => Err(ProtocolError::InvalidMessage),
        Message::Pong(received) => Ok(A2 { received }),
    }
}

// The following generated by macro:
/*#[hax_lib_macros::exclude]
impl TryFrom<(A1, Message)> for A2 {
    type Error = ProtocolError;

    fn try_from((state, msg): (A1, Message)) -> Result<Self, Self::Error> {
        read_pong(state, msg)
    }
}
#[hax_lib_macros::exclude]
impl ReadState<A2> for A1 {
    type Message = Message;
    fn read(self, msg: Message) -> ProtocolResult<A2> {
        A2::try_from((self, msg))
    }
}*/
